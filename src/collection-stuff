



const searchAPI = 'https://www.metmuseum.org/mothra/collectionlisting/search?';

const defaultFacetObjectArray = [];
for (let i = 0; i < 4; i++) {
	defaultFacetObjectArray.push({id: `dfa-${i}`,"options":[]});
}

const pageSizeOptions = [20,40,80];

const sortByFields = [
	{value: "", name: "Relevance"},
	{value: "Title", name: "Title (a-z)"},
	{value: "TitleDesc", name: "Title (z-a)"},
	{value: "DateDesc", name: "Date (newest-oldest)"},
	{value: "Date", name: "Date (oldest-newest)"},
	{value: "ArtistMaker", name: "Artist/Maker (a-z)"},
	{value: "ArtistMakerDesc", name: "Artist/Maker (z-a)"},
	{value: "AccesionNumber", name: "Accession Number (0-9)"},
	{value: "AccesionNumberDesc", name: "Accession Number (9-0)"}
];

const showOnlyOptions = [
	{value: "highlights", name: "Highlights"},
	{value: "withImage", name: "Artworks With Image"},
	{value: "onDisplay", name: "Artworks on Display"},
	{
		value: "openAccess",
		name: "Open Access",
		icon: "i",
		iconText: `<div>As part of the Met's
			<a href="https://www.metmuseum.org/about-the-met/policies-and-documents/open-access">Open Access policy</a>,
			you can freely copy, modify and distribute this image, even for commercial purposes.
		</div>
		<em>API</em>Public domain data for this object can also be accessed using the Met's
		<a target="_new" href="https://metmuseum.github.io/">Open Access API</a>`
	},
	{
		value: "NEprovenance",
		name: "Nazi-era provenance",
		icon: "i",
		iconText: `Objects with changed or unknown ownership in continental Europe between 1933-1945.
		<a href="https://www.metmuseum.org/about-the-met/policies-and-documents/provenance-research-project">Learn more</a>`
	}
];

const placeholderCollectionItem = {
	"url": "",
	"image": "https://www.metmuseum.org/content/img/placeholders/NoImageAvailableIcon.png",
	"artist": "",
	"data": ""
}


	const [searchParamsString, setSearchParamsString] = useState("");
	const [isSearching, setIsSearching] = useState(false);

	const [query, setQuery] = useState("");
	const [searchField, setSearchField] = useState("");
	const [sortBy, setSortBy] = useState("Relevance");
	const [facets, setFacets] = useState(defaultFacetObjectArray);
	const [showOnly, setShowOnly] = useState({});

	const [perPage, setPerPage] = useState(20);
	const [offset, setOffset] = useState(0);
	const [totalResults, setTotalResults] = useState(20001);

	const [results, setResults] = useState(Array(perPage).fill(placeholderCollectionItem));

	const [darkMode, setDarkMode] = useState(false);

	const topRef = React.createRef();

	const formatAndSetFacets = oldFacets => {
		oldFacets.shift();
		const newFacets = oldFacets.map(facet => {
			facet.selectedValues = [];
			facet.options = [];
			facet.values.forEach(option => {
				const formattedOption = {
					"selected": option.selected,
					"label": <span dangerouslySetInnerHTML={{ __html: `${option.label} <span class="option-count">(${option.count})</span>` }} />,
					"value": option.id
				};
				option.selected && facet.selectedValues.push(formattedOption);
				facet.options.push(formattedOption);
			});

			return facet;
		});
		setFacets(newFacets);
	};

	const callAPI = async () => {
		setIsSearching(true);
		abortController && abortController.abort();
		abortController = new AbortController();
		const request = await fetch(`${searchAPI}${searchParamsString}`, { signal: abortController.signal });
		const response = await request.json();
		if (response.results) {
			setResults(response.results);
			formatAndSetFacets(response.facets);
			setTotalResults(response.totalResults);
		} else {
			console.log("No Results");
		}
	};

	const searchCollection = async () => {
		try {
			await callAPI();
		} catch (e) {
			console.error(e);
		} finally {
			abortController = null;
			setIsSearching(false);
		}
	}

	const handleSearchQueryChange = (param, event) => {
		const paramsObject = new URLSearchParams(searchParamsString);
		paramsObject.set(param, event.target.value);
		paramsObject.set("offset", 0);
		setOffset(0);
		setSearchParamsString(paramsObject.toString());
	};

	const handleFacetChange= (e, facet) => {
		const paramsObject = new URLSearchParams(searchParamsString);
		const newValue = e.map(selectedFacet => selectedFacet.value).join("|")
		paramsObject.set(facet.id, newValue);
		paramsObject.set("offset", 0);
		setOffset(0);
		setSearchParamsString(paramsObject.toString());
	};

	const handleShowOnlyChange = event => {
		const target = event.target;
		const isChecked = target.type === 'checkbox' ? target.checked : target.value;
		const name = target.name;
		let newShowOnly = showOnly;

		if (isChecked) {
			newShowOnly[name] = true;
		} else {
			delete newShowOnly[name];
		}
		const showOnlyString = Object.keys(newShowOnly).join("|");
		const paramsObject = new URLSearchParams(searchParamsString);
		paramsObject.set("offset", 0);
		setOffset(0);
		paramsObject.set("showOnly", showOnlyString);
		setSearchParamsString(paramsObject.toString());
	};

	const handlePaginationChange = e => {
		const paramsObject = new URLSearchParams(searchParamsString);
		const newOffset = Math.max(0, parseInt(e.target.value) + parseInt(offset));

		paramsObject.set("offset", newOffset);
		setSearchParamsString(paramsObject.toString());
		setOffset(newOffset);
	};

	const handlePerPageChange = event => {
		const paramsObject = new URLSearchParams(searchParamsString);
		paramsObject.set("perPage", event.target.value);
		setSearchParamsString(paramsObject.toString());
		setPerPage(event.target.value);
	};

	const setStateFromURLParams = params => {
		setQuery(params.get("q") || "");
		setSearchField(params.get("searchField") || "");
		setSortBy(params.get("sortBy") || "Relevance");
		setPerPage(parseInt(params.get("perPage")) || 20);
		setOffset(parseInt(params.get("offset")) || 0);
		if (params.get("showOnly") !== "null" && params.get("showOnly")) {
			const showOnlyObj = params.get("showOnly").split("|").reduce((o, key) => ({ ...o, [key]: true}), {})
			setShowOnly(showOnlyObj);
		}
	};

	const scrollToRef = ref => {
		ref.current.scrollIntoView({
			block: 'start',
			behavior: 'smooth'
		});
	};

	useEffect(() => {
		const url = new URL(`${window.location}`);
		const params = new URLSearchParams(url.search.slice(1));
		setSearchParamsString(params.toString());
		setDarkMode(params.get("darkmode"));
	}, []);

	useEffect(() => {
		searchCollection();
		const params = new URLSearchParams(searchParamsString);
		params["offset"] === "0" && params.delete("offset");
		[...params.entries()].forEach(([key, value]) => {
			if (key === "offset" && value === "0") {
				params.delete(key);
			}
			if (!value) {
				params.delete(key);
			}
		});
		window.history.replaceState({}, '', `${location.pathname}?${params}`);
		setStateFromURLParams(params);
	}, [searchParamsString]);

	const mainClasses = () => {
		const classArry = ["collection-search",
			darkMode ? "darkmode" : "",
			isSearching ? "is-searching" : ""];

		return classArry.join(" ");
	}


